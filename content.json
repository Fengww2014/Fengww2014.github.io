{"pages":[{"title":"about","text":"It’s never too old to learn","link":"/about/index.html"}],"posts":[{"title":"HTTP全解","text":"http是目前访问网页最主流的应用层协议，但是对于http应用层和下面的传输层之间的关系，一直不是特别的清楚，遂就本文对http协议从网络层次的角度来仔细剖析，并写了python脚本试图复原整个的http请求全流程。 1. 用scapy实现http请求全流程1.1 http请求和响应的全流程主要的步骤包括建立连接、http request和response交互、关闭连接等，下面逐一讲解。 1.2 TCP/IP协议TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中（如果局域网是小溪，很多条小溪就汇聚成大的干流，比如长江、黄河，干流就是广域网，然后再流入大海，大海就是互联网），目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的，http协议是无状态，面向连接的，位于应用层的协议。下面的思维导图是tcp/ip涉及到的知识框架。 (1). 链路层也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。 (2). 网络层也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。 IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。 ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。 IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。 (3). 传输层主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。 TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。 UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。 (4). 应用层应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。 数据包进入到每一个层，都会被加上相应的头部，各层的协议就是数据包头部的规范，是统一的数据包结构说明。 包可以说是全能性术语； 帧用于表示数据链路层中包的单位； 数据包是 IP 和 UDP 等网络层以上的分层中包的单位； 段则表示 TCP 数据流中的信息； 消息是指应用协议中数据的单位 从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程 下面再看上面的的；流程是如何一步一步完成的，各个层分别做了什么作用。 1.3 TCP三次握手 HTTP基本都是基于TCP的，TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误： 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 1.4 HTTP协议Http是什么？通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 四个基于： 请求与响应： 客户端发送请求，服务器端响应数据 无状态的： 协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。 应用层： Http是属于应用层的协议，配合TCP/IP使用。 TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。 针对无状态的一些解决策略： 有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。 HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。等等还有很多。。。。。。 下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。 HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求行分为三个部分：请求方法、请求地址和协议版本 1. 请求方法 HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE 2.请求头部 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 下面是http response包的一些结构具体的可以参照下面的实例 http response的结构实例 1234567891011121314151617181920212223242526272829303132333435363738394041HTTP/1.1 200 OK 状态行Date: Sun, 17 Mar 2017 08:12:54 GMT 响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0,pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8空行 响应数据HTTP响应示例Hello HTTP! 下面是python脚本，利用scapy模块库，生成数据包，建立tcp三次握手，传输http报文的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#! /usr/bin/env python# Change log level to suppress annoying IPv6 errorimport logginglogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)# Import scapyfrom scapy.all import *# Print info headerprint \"[*] ACK-GET example -- Thijs 'Thice' Bosschert, 06-06-2011\"# Prepare GET statementget = 'GET / HTTP/1.1\\r\\nHost:49.234.82.163\\r\\nUser-Agent:python/2.7\\r\\nAccept:*/*\\r\\n\\r\\n'# Set up target IPip=IP(dst=\"49.234.82.163\")# Generate random source port numberport=RandNum(1024,65535)# Create SYN packetSYN=ip/TCP(sport=port, dport=80, flags=\"S\", seq=42)# Send SYN and receive SYN,ACKprint \"\\n[*] Sending SYN packet\"SYNACK=sr1(SYN)# Create ACK with GET requestACK=ip/TCP(sport=SYNACK.dport, dport=80, flags=\"A\", seq=SYNACK.ack,ack=SYNACK.seq + 1) # SEND our ACK-GET requestprint \"\\n[*] Sending ACK-GET packet\"send(ACK)reply,error=sr(ip/TCP(sport=SYNACK.dport, dport=80, flags=\"PA\", seq=SYNACK.ack,ack=SYNACK.seq + 1)/get)# print reply from serverprint \"\\n[*] Reply from server:\"print reply.show()print reply[0]print '\\n[*] Done!' 可以用抓包的wireshark发现服务器端有回复ok，也可以用sniff（）来嗅探， 12345其中iface因电脑而异的，然后可以看到如下所示，具体的是哪一个索引也跟目前电脑运行的状态有关，可以多输出几个试试但是握手过程可能会因为tcp的RST而导致握手失败，只主要是linux内核收到ack时，认为自己并没有发出SYN，所以发出RST，重置连接，需要配置iptable过滤掉RST的包，下面的IP为clinet端的ip```iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.20 -j DROP 2. http/url & p4存在的问题 http面向连接的，是需要占用端口的，如果实现的话，需要实现tcp层的功能 http的request和response不是一一对应关系，而且他们的对应序列也可以按照网络不同而不同，这由传输层来帮忙完成，需要找到对应关系？？？从抓包的结果来看：一对会话的ack、seq和tcp length有关的即ack = seq + tcp_length；其中seq就等于上一次发过来的ack或者随机也可以 http的response可以是单个数据包，也可以是多个，可以考虑单个的小的响应包","link":"/2019/10/24/HTTP_Comprehensive/"},{"title":"P4-Controller","text":"利用P4 Runtime需要控制器来连接每个转发器，本文就是记录如何通过CLI和python文本连接switch 当网络结构中含有多个交换设备时，利用一个远程主机开启不同的进程运行CLI可以分别连接多个交换设备 123456789# 开启一个terminalsimple_switch_CLI --thrift-port 9090# 默认监视端口是9090，连接的是第一个实例的switch# 再开启一个terminalsimple_switch_CLI --thrift-port 9091# 默认监视端口是9090，递增一个端口号，连接的是第二个实例的switch# 再开启一个terminalsimple_switch_CLI --thrift-port 9092# 默认监视端口是9090，递增2个端口号，连接的是第3个实例的switch 当网络结构中含有多个交换设备时，利用一个远程主机开启不同的进程运行python脚本同样可以分别连接多个交换设备 12345678910# 开启一个terminalcd /home/vagrant/behavioral-model/tools./runtime_CLI.py --thrift-port 9090# 默认监视端口是9090，连接的是第一个实例的switch# 再开启一个terminal./runtime_CLI.py --thrift-port 9091# 默认监视端口是9090，递增一个端口号，连接的是第二个实例的switch# 再开启一个terminal./runtime_CLI.py --thrift-port 9092# 默认监视端口是9090，递增2个端口号，连接的是第3个实例的switch","link":"/2019/11/20/P4-Controller/"},{"title":"P4 Runtime 初步使用","text":"P4Runtime是P4的一个控制面的协议，也叫南向协议，用于下发流表、规则等作用，但是P4一般提供了PCI这一个模块来修改流表等静态存储，这些模块对于需求往往不够，所以本文记录一下如何使用P4Runtime来从控制面读、写、改一些静态的流表、register、counter等。 首先cd到/behavioral-model/tools文件下面，看到目录下有一个runtime_CLI.py,这个文件就是我们用来修改的文件。这个文件本来的功能就是CLI的命令循环，我们可以立足于它做一些自定义的动作，而不需要在CLI的命令行输入，只需要运行一个python脚本就可以了。 runtime_CLI.py里面把所有的API都写在了class RuntimeAPI里面了。而在主程序里面只写了一句 1RuntimeAPI(args.pre, standard_client, mc_client).cmdloop() 所以我们可以在class RuntimeAPI中自己定义一个函数，函数中调用不同的动作组合，然后在主程序里调用这个成员函数就可以实现运行自己规定的那些动作了，而这些动作怎么组合根据个人的需要即可。","link":"/2019/11/20/P4Runtime初步使用/"},{"title":"P4_lang","text":"p4语言简介P4(Programming Protocol-Independent Packet Processors) 是一种数据面的高级编程语言。数据面编程就是我们自定义匹配字段 ，自定义动作类型 ， 从而自定义流表 ，进而形成流水线。p4不仅可以对数据流进行转发，还可以对交换机等转发设备的数据处理流程进行软件编程定义。p4语言实现的交换机架构如下图 p4语言特点p4的几个需要注意的点： 可以实现现有协议的转发功能 可以自定义数据包结构 可以在现有协议的基础上进行新的功能开发 SW 风格开发——协议和转发的开发模式类似于软件开发p4的语言要素 headers（metadata） parser table & action control flow codeheaders可以自定义header，添加目前数据包中不存在的字段，便于实现转发时候特定字段的匹配和动作。但是p4写成的程序只负责解析字段，所以还需要软件环境。parser用于解析数据包的headers的状态机，他可以有很多种状态，可以根据来的数据包的状态来选择变成哪个状态，而且有三个预留的状态 start reject accept除这三个之外的状态可以自己定义，状态之间的转变也可以用户自己定义，完全是可编程的。table & actiontable是由controller通过南向协议进行下发，而匹配的模式可以由p4语言来确定，table只提供了表，怎么去查表，查表之后进行怎么样的动作，也都完全由p4程序来确定，包括匹配的key，下一步的action id，但是action data是由table传出来的。control flow code这部分就像是c++程序里面的顺序结构，规定先干什么，然后在干什么，最后干什么，这部分的可编程化，把交换机的单一功能变得更加自主和智能化。交换机不再仅仅完成简单的ip或者名称匹配，而是又一个复杂的流程需要完成，可以是多个匹配任务的连续，也可以对数据包的包头进行修改，增加，删减等动作。所谓的协议和转发策略一切变得跟软件开发一样简单。","link":"/2019/10/24/P4_data_plane_lang/"},{"title":"P4_tutorials","text":"😍经过接连两周连续每天熟悉p4官方给出的教程，慢慢的对p4有了进一步的理解。👍p4是一个数据面的编程语言，能够对数据包的包头自定义设计、自定义解析，然后设计流程让数据包按照包头的解析结果进行流表的匹配和动作的执行，动作包括：👉对数据包转发给下一个端口，clone数据包，修改数据包的包头、添加或者减少数据包的包头、给控制层转发数据包等等动作。 p4语言的执行流程 官方的教程demo中仅给出的是v1model的target转发模型，P4_16和P4_14都支持这种转发模型，所以我的实验和理解都是基于这种转发模型的。v1model模型图和p4程序的顺序结构如下图所示： 所以呢执行的顺序可以清楚的看出来。 parse状态机的理解 但是针对parse这一环节，我一度很困扰，因为我一直想解析一个不定长的header，但是一直找不到案例，而且在p4_16的语言规范的文档中，提供了一种变长的header结构，但是前提是你得事前知道有多长，类似于ipv4的length字段，尽管ipv4有option字段，但是length字段又明确了长度，所以p4的变长header也是这种机制。但是这对我于p4的header解析，有了一个认识的契机，本来我一直以为这个解析和结构之间的声明顺序有很大的关系，结果，😀发现这个和华为提出的pof架构很类似都是利用偏移来做的解析，只不过p4语言更加高级，你不能从代码上看出偏移，但是本质还是偏移，比如下面这个数据包，（这是用scapy发出的数据包🐍）。 1sendp(Ether()/IP()/TCP()/\"Hello\") 那么当switch收到packet时，👉进入到start state状态，那么可以看出来这个包是第二层的包，那么势必要首先解析的是最外层的Ether层，他是从第0位开始解析到Ether header的size为止，👉那么下一步的状态就转移到parse_ether state状态，并且开始解析ipv4的header，同理他是从Ether结束的下一位一直解析ipv4的size长度位置为止，👉依次下去，所以每次你选择的state的解析动作一定是暴露在最外层的，你不能一上来就直接解析tcp，因为他会以为是从0开始解析tcp header长度个bit位，这是错误的，👍所以哪怕你对于这个header不感兴趣，你也得一层一层的解析header。解析完之后，所有解析过的header都是可以在后面的步骤中直接使用，包括赋值，和引用。 table-match table的match动作可以只包含动作，不含有key那样的话就相当于直接执行默认的action，还有一个就是在apply的流程中不能直接操作action所以可以利用上面的这种机制来直接执行某项action。table同样可以通过CLI来下发，在mininet CLI中输入xterm s1，显示出s1的terminal，这表明这是s1交换机的terminal，然后运行simple_switch_CLI --thrift-port 9090 --json basic.json就可以进入到s1交换机的CLI交互界面，如下图所示，你可以通过输入help显示存在的命令，你也可以通过help+某一个命令来显示这个命令怎么用👍。具体的各种操作可以参照github p4lang的仓库。 这里另外需要讲的就是clone数据包，在p4_14的tutorial中还存在一个copy_to_cpu的案例，但是在p4_16中却不在了😭，所以我找了很多的资料才弄清楚函数的演变关系，现在直接调用clone3函数就可以啦，直接实现clone packet的功能，具体的函数说明可以参照，但是这里我给出一个我实现的流程 clone packet with p4🤜1. 在p4_16的tutorial的basic案例中的basic.p4文件中加入clone3(CloneType.I2E,250,standard_metadata);，只是要加在ingress中的，这个与第一个参数相对应，第一个参数表明是ingress->egress，所以要与之对应，🤜2. 第二个参数是mirror_id，这个后面需要在CLI中下发，类似于一个流表的变量，下发mirror时需要用到下面的命令mirroring_add 250 3,这表明第二个参数是250时需要从2端口转出去，这个与原来的packet是不相干的，最后一个我暂时还不是很明确能干什么，因为也有一个函数clone这就相当于没有第三个参数。但是cloned packet与原本的packet之间的区别由standard_metadata.instance_type可以区分，所以在egress中可以通过匹配standard_metadata.instance_type来实现修改目的地址的动作，需要在控制面输入table_add direct change_ipv4 1 =>来配置流表，使得当匹配的key：standard_metadata.instance_type为1时，采取change_ipv4的action.👌这样就可以实现clone数据包了，实现的结果就是当你从h1发出一个数据包时，能在h2收到两个。","link":"/2019/10/24/P4_tutorials/"},{"title":"P4app-docker","text":"介绍p4appp4app是一个可以构建、运行、调试和测试P4程序的工具，p4app背后蕴含的哲学是“简单的事情应尽可能简单”，旨在使小而简单的P4程序易于编写、易于与他人分享。这个工具站的角度比较高，忽略了底层的一些配置，让用户了解p4的门槛变低，直接开始设计p4程序。👌 p4lang/p4app的镜像结构Docker 镜像是分层结构以Ubuntu 16.04为base镜像依次构建，p4app为最顶层.对于如何构建这些镜像，有兴趣的可以看p4app的Dockerfile.💪 p4app p4c pi bmv2 third-party ubuntu：16.04 安装p4app 前提保证机器上安装了docker 🖥下载github的p4app源码1234git clone https://github.com/p4lang/p4app.git cd p4appsudo cp p4app /usr/local/binp4app run examples/simple_router.p4app 😘 其他具体的说明参照https://github.com/p4lang/p4app中README.md的说明。 下面讨论下p4c 和 p4c-bm 的关系以及 p4factory 和 p4app 的关系从sdnlab网站上帖子的理解，大概是这样的：P4语言(P4_14)提出不久时，p4-hilr：https://github.com/p4lang/p4-hlir是它的编译器，P4软件交换机是BMv1: https://github.com/p4lang/p4c-behavioral；同时，为使大家更好的上手P4语言，提供了p4factory和tutorials这两个仓库；后来P4社区使用C++重写了BMv1软件交换机，形成现在通用的P4软件交换机BMv2：🖥https://github.com/p4lang/behavioral-model，并对p4-hilr编译器做了对应的拓展，形成p4c-bm编译器，p4c-bm 只支持 p4-14 而且指针对 bmv2 这个目标，而 p4c 可以支持 p4-14 和 p4-16，而且包含了多个后端编译器。16年，为解决P4_14语言的语法问题和限制，社区开发了P4_16语言，并基于P4_16语言做了新的编译器p4c；p4c是P4语言的前端编译器，🌐既支持p4_16语言也支持p4_14语言，同时允许各大厂商开发架构相关的的后端编译器，即对应于ebpf、bmv2、tofino、NetFPGA等架构的后端编译器。这个过程中，P4语言官方教程Tutorial是不断更新的，而p4factory不再被官方维护，所以如果要上手P4的话建议从Tutorial开始。p4app是通过docker环境运行P4实验的一个仓库，可以参考上面的教程或者想多了解可以访问孙勇峰老师的博客：sunyongfeng.com/201705/networks/p4/repo_p4app.html。","link":"/2019/10/24/P4app_Docker/"},{"title":"virtualbox-build-topo","text":"多台虚拟机搭建网络拓扑利用多台虚拟机搭建彼此之间的拓扑关系，进行一些试验，而不限于实际交换设备数量的限制。 在virtualbox软件上创建多台虚拟机，我用三个来试验，两台作为主机，一台作为路由 进行两台主机的网络配置 配置路由器 主机的配置选择相应的虚拟机1右键点击 选择设置-网络 填写连接方式为内部网络，并设定界面名称为inet-1 选择相应的虚拟机2右键点击 选择设置-网络 填写连接方式为内部网络，并设定界面名称为inet-2 路由器的配置选择路由器的3号虚拟机右键点击 选择设置-网络 填写网卡1连接方式为内部网络，并设定界面名称为inet-1 同样设定网卡2位内部网络，inet-2 开启三台虚拟机在1,2虚拟机上设定网卡的IP地址和默认网关 12sudo ifconfig enp0s3 192.168.1.2 netmask 255.255.255.0sudo route add default gw 192.168.1.1 同样设定另一主机，保证不再同一网段，比如设另一台ip为192.168.2.2，网关为192.168.2.1，这样两台主机就设定配置完毕，但是此时h1 无法ping 通h2 在3的路由器虚拟机上同样为两张网卡设定IP，网卡一为192.168.1.1，另一为192.168.2.1下面需要设置转发路由表,允许ubuntu转发123sudo ip route add 192.168.2.0/24 via 192.168.2.1sudo ip route add 192.168.1.0/24 via 192.168.1.1echo 1 > /proc/sys/net/ipv4/ip_forward 然后h1就可以ping通h2了。","link":"/2019/10/17/virtualbox-build-topo/"},{"title":"python_loop_break","text":"本文总结python 语言定时跳出循环的方案，主要分为两种情况： 循环中无阻塞的可能这种情况比较简单，可以直接用时间差的判断是否跳出即可：12345import timet_end = time.time() + 60 * 15while time.time() < t_end: # do whatever you do但是必须保证不存在阻塞的可能 循环中可能会发生阻塞这种就比较复杂，因为可能循环会阻塞在特定的语句，所以无法用上面的方法来实现，必须要另开一线程来使循环线程和计时判断线程同时进行，这样就不会有阻碍了。下面的代码是我查资料采取的方案：1234567891011121314151617181920from multiprocessing import Processimport timedef task(msg): while 1: print ('hello, %s' % msg) time.sleep(1) pass if __name__ == '__main__': p = Process(target=task, args=('world',)) p.start() p.join(0.15) if p.is_alive(): print('Process: %s is running' % p.pid) p.terminate() 尽管这个task中的循环不包括阻塞的可能，但是这段代码是可以完全应对发生阻塞的情况。","link":"/2019/10/10/python-loop-break/"},{"title":"icarus_configure","text":"自定义icarus主题的配置，使个人博客看起来很舒服。 雪花特效 在/themes/icarus/source/js/目录下新建一个src目录，在src目录中新建snow.js文件，把下面的代码写到snow.js文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / 60); };cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){ /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)}/* 创建画布 */function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function() { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */}flakeMove.prototype.update = function() { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY = canvas.width || this.x = canvas.height || this.y","link":"/2019/10/10/icarus-configure/"}],"tags":[{"name":"http","slug":"http","link":"/tags/http/"},{"name":"P4","slug":"P4","link":"/tags/P4/"},{"name":"networks","slug":"networks","link":"/tags/networks/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"http","slug":"http","link":"/categories/http/"},{"name":"networks","slug":"networks","link":"/categories/networks/"},{"name":"P4","slug":"P4","link":"/categories/P4/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}